/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  1.6                                   |
|   \\  /    A nd           | Web:      http://www.OpenFOAM.org               |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volVectorField;
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField   uniform (0 0 0);

boundaryField
{
    inlet
    {
        type            codedFixedValue;
        value           uniform (0 0 0);
        redirectType    turbInlet;

        codeInclude
        #{
            #include "fvCFD.H"
            #include "H5Cpp.h"
        #};

        codeOptions
        #{
            -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude \
            -I/home/wan39502/quanah.local/hdf5/include
        #};

        codeLibs
        #{
            -lfiniteVolume \
            -lmeshTools \
            -L/home/wan39502/quanah.local/hdf5/lib \
            -lhdf5_hl_cpp \
            -lhdf5_cpp \
            -lhdf5_hl \
            -lhdf5 \
            -lpthread \
            -lz \
            -ldl \
            -lm
        #};

        code
        #{
            // const IOdictionary& d = static_cast<const IOdictionary&>
            // (
            //     dict.parent().parent()
            // );

            // const fvMesh& mesh = refCast<const fvMesh>(d.db());
            // const label id = mesh.boundary().findPatchID("inlet");
            // const fvPatch& patch = mesh.boundary()[id];

            // vectorField U(patch.size(), vector(0, 0, 0));

            const fvPatch& boundaryPatch = patch();
            const vectorField& Cf = boundaryPatch.Cf();
            vectorField& field = *this;


            // Parameters for HDF5 databases
            const std::string FILE_NAME("lesinlet.h5");
            const std::string DATASET_NAME_UMEAN("UMEAN");
            const std::string DATASET_NAME_U("U");
            const std::string DATASET_NAME_V("V");
            const std::string DATASET_NAME_W("W");
            const std::string DATASET_NAME_GRID("GRID");
            const std::string DATASET_NAME_TIME("TIME");

            // Read HDF5 into array
            // U
            H5::H5File file(FILE_NAME, H5F_ACC_RDONLY);
            H5::DataSet dataset = file.openDataSet(DATASET_NAME_U);
            H5::DataSpace dataspace = dataset.getSpace();
            hsize_t dims_u[2];
            int ndims = dataspace.getSimpleExtentDims(dims_u, NULL);
            const int NX = dims_u[0];
            const int NT = dims_u[1];
            // Define the memory dataspace
            hsize_t dims_mem_u[2];
            dims_mem_u[0] = NX;
            dims_mem_u[1] = NT;
            H5::DataSpace mem_space_u(2, dims_mem_u);
            double Ux[NX][NT];
            dataset.read(Ux, H5::PredType::NATIVE_DOUBLE, mem_space_u, dataspace);

            // V
            dataset = file.openDataSet(DATASET_NAME_V);
            dataspace = dataset.getSpace();
            // Define the memory dataspace
            double Uy[NX][NT];
            dataset.read(Uy, H5::PredType::NATIVE_DOUBLE, mem_space_u, dataspace);

            // W
            dataset = file.openDataSet(DATASET_NAME_W);
            dataspace = dataset.getSpace();
            // Define the memory dataspace
            double Uz[NX][NT];
            dataset.read(Uz, H5::PredType::NATIVE_DOUBLE, mem_space_u, dataspace);

            // UMEAN
            dataset = file.openDataSet(DATASET_NAME_UMEAN);
            dataspace = dataset.getSpace();
            hsize_t dims_umean[1];
            dims_umean[0] = NX;
            hsize_t dims_mem_umean[1];
            dims_mem_umean[0] = NX;
            H5::DataSpace mem_space_umean(1, dims_mem_umean);
            double Umean[NX];
            dataset.read(Umean, H5::PredType::NATIVE_DOUBLE, mem_space_umean);

            // Need more general code
            scalar startTime = 0.0;
            scalar deltaT = 0.001;

            // current time
            scalar t = this->db().time().value();

            int tI = static_cast<int>((t - startTime) / deltaT);

            forAll(Cf, faceI)
            {
                field[faceI] =
                    vector
                    (
                        Ux[faceI][tI] + Umean[faceI],
			//10,
                        Uy[faceI][tI],
			//0,
                        Uz[faceI][tI]
                        //0
                    );
		//Info << "face: " << faceI << " UMean: " << Ux[faceI][tI] + Umean[faceI] << endl;
            }
        #};
    }

    outlet
    {
        type            pressureInletOutletVelocity;
        value           uniform (0 0 0);
    }

    ground
    {
        type            fixedValue;
        value           uniform ( 0 0 0 );
    }

    building
    {
        type            fixedValue;
        value           uniform ( 0 0 0 );
    }

    sides
    {
        type            symmetry;
    }

    top
    {
        type            symmetry;
    }
}

// ************************************************************************* //
